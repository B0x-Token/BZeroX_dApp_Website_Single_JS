<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockchain Data Charts</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.10.0/web3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #f2f2f2;
            margin: 0;
            padding: 20px;
        }
        .chart-container {
            margin: 20px 0;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }
        .controls {
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        #topText, #topText2 {
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="topText">Loading blockchain data...</div>
    <div id="topText2">This may take a few minutes...</div>
    
    <div class="controls">
        <button onclick="updateGraphData(30, 30)">30 Days</button>
        <button onclick="updateGraphData(60, 60)">60 Days</button>
        <button onclick="updateGraphData(120, 120)">120 Days</button>
    </div>

    <div class="chart-container">
        <h3>Difficulty & Hashrate</h3>
        <div id="difficultystats">Loading...</div>
    </div>

    <div class="chart-container">
        <h3>Block Time & Supply</h3>
        <div id="blocktimestats">Loading...</div>
    </div>

    <div class="chart-container">
        <h3>Price Over Time</h3>
        <div id="priceOverTimestats">Loading...</div>
    </div>

    <div class="chart-container">
        <h3>Average Revenue</h3>
        <div id="avgRevenue">Loading...</div>
    </div>

    <script>



        // Configuration constants
        const _MAXIMUM_TARGET_STR_OLD = "27606985387162255149739023449108101809804435888681546220650096895197184";  // 2**234
        const BWORK_RPC = 'https://base-mainnet.g.alchemy.com/v2/u6woRjFLe5-e3SfnCYFnfoTlgVUangV3';
        const BWORK_CONTRACT_ADDRESS = '0x2f38B1a516239739CdCD2C228D1Eb96E29800975';
        const BWORK_LAST_DIFF_START_BLOCK_INDEX = '4';
        const BWORK_ERA_INDEX = '5';
        const BWORK_TOKENS_MINTED_INDEX = '11';
        const BWORK_MINING_TARGET_INDEX = '6';
        
        const _SECONDS_PER_ETH_BLOCK = 2;
        const _IDEAL_BLOCK_TIME_SECONDS = 600;
        const _HASHRATE_MULTIPLIER = 2**22;
        const _CONTRACT_NAME = 'BWORK';
        
        // These will be initialized after web3 is ready
        let ethblockstart = 30413732;
        let adjustAverageRewardTimeGraph = 8;
        let searchPoints2 = 120;
        let latest_eth_block = null;
        let BWORK_latest_eth_block = null;
        let web3 = null;
        let _ZERO_BN;
        let _MAXIMUM_TARGET_BN_OLD;
        let retryAt = 0;

        // Helper functions
        function el(selector) {
            return document.querySelector(selector);
        }

        function log(...args) {
            console.log(...args);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function toReadableThousands(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }

        function toReadableThousandsLong(num) {
            return num.toLocaleString();
        }

        function toReadableHashrate(hashrate) {
            if (hashrate >= 1e12) {
                return (hashrate / 1e12).toFixed(2) + ' TH/s';
            } else if (hashrate >= 1e9) {
                return (hashrate / 1e9).toFixed(2) + ' GH/s';
            } else if (hashrate >= 1e6) {
                return (hashrate / 1e6).toFixed(2) + ' MH/s';
            } else if (hashrate >= 1e3) {
                return (hashrate / 1e3).toFixed(2) + ' KH/s';
            }
            return hashrate.toFixed(2) + ' H/s';
        }

        function ethBlockNumberToTimestamp(blockNumber) {
            // Use a more recent reference point for Base network
            // Block 34966000 ≈ December 2024 (adjust this based on current date)
            const referenceBlock = 34966000;
            const referenceTimestamp = Date.now() / 1000; // Current timestamp
            const avgBlockTime = 2; // Base network block time
            
            const blockDifference = blockNumber - referenceBlock;
            const timeDifference = blockDifference * avgBlockTime;
            const blockTimestamp = referenceTimestamp + timeDifference;
            
            return new Date(blockTimestamp * 1000).toLocaleDateString();
        }

        function ethBlockNumberToTimestamp2(blockNumber) {
            const referenceBlock = 34966000;
            const referenceTimestamp = Date.now() / 1000;
            const avgBlockTime = 2;
            
            const blockDifference = blockNumber - referenceBlock;
            const timeDifference = blockDifference * avgBlockTime;
            const blockTimestamp = referenceTimestamp + timeDifference;
            
            return new Date(blockTimestamp * 1000).toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
        }

        function BWORKethBlockNumberToDateStr(blockNumber) {
            return ethBlockNumberToTimestamp2(blockNumber);
        }

        function goToURLAnchor() {
            // Placeholder function
        }



    

// Alternative approach - always try to add first, then switch
async function switchToBaseMainnet() {
    const baseMainnetConfig = {
        chainId: '0x2105', // 84532 in hex
        chainName: 'Base',
        nativeCurrency: {
            name: 'Ethereum',
            symbol: 'ETH',
            decimals: 18
        },
        rpcUrls: ['https://mainnet.base.org'],
        blockExplorerUrls: ['https://basescan.org/']
    };
    
    try {
        // Try to add the network first (this will do nothing if it already exists)
        await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [baseMainnetConfig]
        });
        console.log('Base Mainnet network added/confirmed');
        
        // Then switch to it
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: baseMainnetConfig.chainId }]
        });
        console.log('Switched to Base Mainnet network');
        
    } catch (error) {
        console.error('Error with Base Mainnet network:', error);
        throw new Error(`Failed to setup Base Mainnet network: ${error.message}`);
    }
}



var retryAt1123123123 = 0;
        // Initialize Web3 connection
        async function initEth() {
            try {
                if (window.ethereum) {
                   // web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    await switchToBaseMainnet();

                    web3 = new Web3(window.ethereum);
                } else {
                    web3 = new Web3(new Web3.providers.HttpProvider(BWORK_RPC));
                }
                
                // Initialize BigNumber constants after web3 is ready
                _ZERO_BN = new web3.utils.BN(0);
                _MAXIMUM_TARGET_BN_OLD = new web3.utils.BN(_MAXIMUM_TARGET_STR_OLD, 10);
                
                // Get latest block
                const latestBlock = await web3.eth.getBlockNumber();
                BWORK_latest_eth_block = latestBlock;
                latest_eth_block = BWORK_latest_eth_block;
                
                log('Connected to Base Mainnet. Latest block:', BWORK_latest_eth_block);
            } catch (error) {
                console.error('Failed to connect to Ethereum:', error);
                // Initialize fallback values
                web3 = new Web3(new Web3.providers.HttpProvider(BWORK_RPC));
                _ZERO_BN = new web3.utils.BN(0);
                _MAXIMUM_TARGET_BN_OLD = new web3.utils.BN(_MAXIMUM_TARGET_STR_OLD, 10);
                // Use a fallback block number if connection fails
                try{
                BWORK_latest_eth_block =  await web3.eth.getBlockNumber();
                latest_eth_block = BWORK_latest_eth_block;
                }catch(error){
                    console.log("ERROR : ",error);
                    sleep(2000 * retryAt1123123123**2);
                    initEth();
                    retryAt1123123123 +=1;
                    if(retryAt1123123123 > 3){
                        return;
                    }
                    
                }
                retryAt1123123123=0;
            }
        }



class contractValueOverTime {
  constructor(web3Instance, contract_address, storage_index, descriptor) {
    this.WAIT_DELAY_FIXED_MS = 120;
    this.WAIT_DELAY_ON_TIMEOUT_MS = 1500;
    this.web3 = web3Instance;
    this.contract_address = contract_address;
    this.storage_index = storage_index;
    this.descriptor = descriptor;
    this.sorted = false;
    this.states = [];
    this.expected_state_length = 0;
    this.pending_requests = [];
  }

  get getValues() {
    return this.states;
  }

  printValuesToLog() {
    this.states.forEach((value) => {
      log('block #', value[0], 'ts', value[2], 'value[1]:', value[1].toString(10));
    });
  }

  // ✅ Load cached blocks in range


  // --- Load cached states from localStorage for a given range ---
  loadFromCache(startBlock, endBlock, timeRangeLabel) {
const contractPrefix = BWORK_CONTRACT_ADDRESS.slice(0, 7); // Includes '0x' + 8 hex chars

    const key = `${this.descriptor}_${timeRangeLabel}_${contractPrefix}`;
    let cache = JSON.parse(localStorage.getItem(key)) || {};
    let results = [];

    for (let blockStr in cache) {
      let block = parseInt(blockStr, 10);
      if (block >= startBlock && block <= endBlock) {
        let value_bn = new this.web3.utils.BN(BigInt('0x' + cache[blockStr]).toString(), 10);
        results.push([block, value_bn, '']);
      }
    }

    results.sort((a, b) => a[0] - b[0]);
    this.states.push(...results);
    this.expected_state_length += results.length;

    return results;
  }


async addValuesInRange(start_eth_block, end_eth_block, num_search_points, tolerance = 100) {
  // Calculate step size
  const stepsize = Math.floor((end_eth_block - start_eth_block) / num_search_points);
  console.log('stepsize', stepsize, 'num_search_points', num_search_points);

  // Load cached blocks using num_search_points as the label
  const cached = this.loadFromCache(start_eth_block, end_eth_block, num_search_points);
  if (cached.length > 0) {
    console.log(`Loaded ${cached.length} cached blocks for ${this.descriptor}_${num_search_points}`);
  }

  // Track loaded blocks globally
  const loadedBlocks = Array.from(this.states.map(s => s[0]));

  // Align end block to UTC midnight
  const d = new Date();
  const secondsSinceMidnight = (d.getTime() - d.setUTCHours(0,0,0,0)) / 1000;
  const blocksSinceMidnight = Math.floor(secondsSinceMidnight / _SECONDS_PER_ETH_BLOCK);
  const alignedEndBlock = end_eth_block - blocksSinceMidnight;

  // Collect blocks to fetch
  const blocks_to_fetch = [];
  for (let i = 0; i < num_search_points; i++) {
    const block_num = alignedEndBlock - (stepsize * i);

    // Reuse cached blocks within tolerance
    const exists = loadedBlocks.some(b => Math.abs(b - block_num) <= tolerance);
    if (!exists) {
      blocks_to_fetch.push(block_num);
    }
  }

  if (blocks_to_fetch.length > 0) {
    await this.batchGetStorageAt(blocks_to_fetch);
  }
}


async batchGetStorageAt(blockNumbers, batchSize = 20) {
    blockNumbers = blockNumbers.filter(block => block >= ethblockstart);
    if (blockNumbers.length === 0) return;

    // Precompute storage slot once
    let storageSlot;
    if (this.storage_index?.slice(0, 2) == '0x') {
        if (this.storage_index.length > 10) {
            storageSlot = this.storage_index;
        } else {
            storageSlot = '0x' + new this.web3.utils.BN(this.storage_index.slice(2), 16).toString(16);
        }
    } else {
        storageSlot = '0x' + new this.web3.utils.BN(this.storage_index, 10).toString(16);
    }

    for (let i = 0; i < blockNumbers.length; i += batchSize) {
        const batch = blockNumbers.slice(i, i + batchSize);
        const batchNumber = Math.floor(i/batchSize) + 1;
        const totalBatches = Math.ceil(blockNumbers.length/batchSize);
        
        log(`Processing batch ${batchNumber}/${totalBatches} for ${this.descriptor}`);

        try {
            // Create all promises for the batch
            const promises = batch.map(blockNum => 
                this.web3.eth.getStorageAt(
                    this.contract_address, 
                    storageSlot, 
                    Math.round(blockNum)
                )
                .then(value => this.processStorageValue(Math.round(blockNum), value))
                .catch(error => {
                    console.error('Error fetching block', blockNum, ':', error);
                    // Fallback: add default value
                    return this.addValueAtEthBlock(blockNum);
                })
            );

            // Execute all requests concurrently
            await Promise.all(promises);
            
            this.expected_state_length += batch.length;

                await sleep(200);
            // Rate limiting between batches
            if (i + batchSize < blockNumbers.length) {
                await sleep(400);
            }

        } catch (error) {
            console.error('Batch request failed:', error);
            
            // Fallback: process each block individually with retries
            for (const blockNum of batch) {
                try {
                    const value = await this.web3.eth.getStorageAt(
                        this.contract_address, 
                        storageSlot, 
                        Math.round(blockNum)
                    );
                    await this.processStorageValue(Math.round(blockNum), value);
                } catch (individualError) {
                    console.error('Individual request also failed for block', blockNum, ':', individualError);
                    await this.addValueAtEthBlock(blockNum);
                }
                await sleep(200);
            }
        }
    }
}

  async processStorageValue(eth_block_num, value) {
    if (!value || value == '0x') {
      log('Got bad value for block', eth_block_num, ', retrying...');
      await sleep(this.WAIT_DELAY_ON_TIMEOUT_MS);
      return this.addValueAtEthBlock(eth_block_num, true);
    }

    var hex_str = value.substr(2, 64).replace(/[^0-9a-fA-F]/g, '').padStart(64, '0');

    try {
      let value_bn;
      if (this.storage_index.slice(0, 2) == '0x' && this.storage_index == '0xd66bf39be2869094cf8d2d31edffab51dc8326eadf3c7611d397d156993996da') {
        var sqrtPriceX96 = BigInt('0x' + hex_str.slice(-40));
        var Q96 = BigInt('79228162514264337593543950336');
        value_bn = new this.web3.utils.BN(((sqrtPriceX96 * sqrtPriceX96) / (Q96 * Q96)).toString(), 10);
      } else if (this.storage_index.slice(0, 2) == '0x') {
        var sqrtPriceX96 = BigInt('0x' + hex_str.slice(-40));
        var temp = Number(sqrtPriceX96) / (2**96);
        var final_price = Math.floor((temp ** 2) * 10**12);
        value_bn = new this.web3.utils.BN(final_price.toString(), 10);
      } else {
        value_bn = new this.web3.utils.BN(BigInt('0x' + hex_str).toString(), 10);
      }
      this.states.push([eth_block_num, value_bn, '']);
    } catch (error) {
      console.error('Error processing storage value:', hex_str, 'Error:', error);
    }
  }

  addValueAtEthBlock(eth_block_num, is_retry, retry_delay = 600) {
    if (eth_block_num < ethblockstart) return;

    let cv_obj = this;
    if (!is_retry) this.expected_state_length++;

    let storageSlot;
    if (this.storage_index.slice(0, 2) == '0x') {
      storageSlot = this.storage_index.length > 10 ? this.storage_index :
        '0x' + new this.web3.utils.BN(this.storage_index.slice(2), 16).toString(16);
    } else {
      storageSlot = '0x' + new this.web3.utils.BN(this.storage_index, 10).toString(16);
    }

    this.web3.eth.getStorageAt(this.contract_address, storageSlot, eth_block_num)
      .then(this._getSaveStateFunction(this.states, eth_block_num, retry_delay))
      .catch(async (error) => {
        log('Error reading block storage:', error);
        await sleep(retry_delay);
        cv_obj.addValueAtEthBlock(eth_block_num, true, retry_delay * 2);
      });
  }

  _getSaveStateFunction(block_states, eth_block_num, retry_delay) {
    let cv_obj = this;
    if (!retry_delay) retry_delay = cv_obj.WAIT_DELAY_ON_TIMEOUT_MS;

    return async function(value) {
      if (!value || value == '0x') {
        log('Bad value, retrying block', eth_block_num);
        await sleep(retry_delay);
        cv_obj.addValueAtEthBlock(eth_block_num, true, retry_delay * 2);
        return;
      }
      await cv_obj.processStorageValue(eth_block_num, value);
    }
  }

  areAllValuesLoaded() {
    log("Expected:", this.expected_state_length, " vs cur Length:", this.states.length);
    return this.expected_state_length === this.states.length;
  }

  async waitUntilLoaded() {
    while (!this.areAllValuesLoaded()) await sleep(500);
  }

  sortValues() {
    log('sorting values..');
    this.states.sort((a, b) => a[0] - b[0]);
    this.sorted = true;
  }


  // --- Save states to localStorage for a given time range ---
  saveToLocalStorage(timeRangeLabel) {
    if (this.states.length === 0) return;
const contractPrefix = BWORK_CONTRACT_ADDRESS.slice(0, 7); // Includes '0x' + 8 hex chars

    const key = `${this.descriptor}_${timeRangeLabel}_${contractPrefix}`;
    let cache = JSON.parse(localStorage.getItem(key)) || {};

    // Merge new states
    for (const [block, bnValue] of this.states) {
      cache[block] = bnValue.toString(16);
    }

    try {
      localStorage.setItem(key, JSON.stringify(cache));
      console.log(`Saved ${Object.keys(cache).length} unique blocks to ${key}`);
    } catch (error) {
      console.error(`Failed to save ${key} to localStorage:`, error);
    }
  }

  // --- Compute UTC midnight block ---
  getMidnightBlock() {
    const d = new Date();
    d.setUTCHours(0, 0, 0, 0);
    const secondsSinceEpoch = Math.floor(d.getTime() / 1000);
    return ethblockstart + Math.floor(secondsSinceEpoch / _SECONDS_PER_ETH_BLOCK);
  }

}




  function getHashrateDataFromDifficultyAndErasPerBlockData(difficulty_data, eras_per_block_data) {
    var expected_eras_per_block = 1/80; //76.5/* should be 40 times slower than ethereum (with 15-second eth blocks) */
    var difficulty_data_index = 0;
    var difficulty_change_block_num = 0;
    var chart_data = []
    for (var step = 0; step < eras_per_block_data.length; step++) {
      var current_eth_block = eras_per_block_data[step].x;
      var current_eras_per_block = eras_per_block_data[step].y;

      while(difficulty_data_index < difficulty_data.length - 1
            && difficulty_data[difficulty_data_index+1].x < current_eth_block) {
        difficulty_change_block_num = difficulty_data[difficulty_data_index+1].x;
        difficulty_data_index += 1;
      }

      //console.log('diff chg @', difficulty_change_block_num);
	var difficulty =0
	try{
      var difficulty = difficulty_data[difficulty_data_index].y.toNumber();
	}catch{
	}
      /* if difficulty change occurs within this step window */
      if (step != 0
          && difficulty_data_index != 0
          && eras_per_block_data[step].x > difficulty_change_block_num
          && eras_per_block_data[step-1].x < difficulty_change_block_num) {

        /* make a new half-way difficulty that takes the duration of each 
           seperate difficulty into accout  */

        var step_size_in_eth_blocks = eras_per_block_data[step].x - eras_per_block_data[step-1].x;
        var diff1_duration = eras_per_block_data[step].x - difficulty_change_block_num;
        var diff2_duration = difficulty_change_block_num - eras_per_block_data[step-1].x;
	var current_difficulty =0
	try{
        current_difficulty = difficulty_data[difficulty_data_index].y.toNumber();
	}catch{
	}
        /* NOTE: since the data is stored kind-of oddly (two values per
           difficulty: both the first and last known block at that value), we
           index difficulty_data as step-1 instead of step-2, skipping a
           value. */
        var last_difficulty = difficulty_data[difficulty_data_index-1].y.toNumber();
        difficulty = (current_difficulty * (diff1_duration/step_size_in_eth_blocks))
                     + (last_difficulty * (diff2_duration/step_size_in_eth_blocks));
        // console.log('step size', step_size_in_eth_blocks);
        // console.log('dif', difficulty);
        // console.log('d curr', eras_per_block_data[step].x, diff1_duration, current_difficulty);
        // console.log('d  old', eras_per_block_data[step-1].x, diff2_duration, last_difficulty);
        // console.log('d', difficulty);
      }

      var unadjusted_network_hashrate = difficulty * _HASHRATE_MULTIPLIER / _IDEAL_BLOCK_TIME_SECONDS;
      var network_hashrate = unadjusted_network_hashrate * (current_eras_per_block/expected_eras_per_block);
      //log('for block', current_eth_block, 'diff', difficulty.toFixed(1), 'uhr', unadjusted_network_hashrate, 'hr', network_hashrate)
	if(current_eth_block > ethblockstart){
      chart_data.push({
        x: current_eth_block,
        y: network_hashrate,
      })
}
      //console.log('log', era_values[step][0], value_mod_function(era_values[step][1]))
      //labels.push(era_values[step][0]);
      //chart_data.push(_MAXIMUM_TARGET_BN.div(values[step][1]));
    }
    return chart_data;
  }



        function generateHashrateAndBlocktimeGraph(web3Instance, target_cv_obj, era_cv_obj, price_cv_obj, price_cv_obj3, tokens_minted_cv_obj) {
          el('#difficultystats').innerHTML = '<canvas id="chart-hashrate-difficulty" width="4rem" height="2rem"></canvas>';
          el('#blocktimestats').innerHTML =  '<canvas id="chart-rewardtime" width="4rem" height="2rem"></canvas>';
          el('#priceOverTimestats').innerHTML =  '<canvas id="chart-pricetime" width="4rem" height="2rem"></canvas>';
          el('#avgRevenue').innerHTML =  '<canvas id="chart-AvgRevenue" width="4rem" height="2rem"></canvas>';

          var target_values = target_cv_obj.getValues;
          var era_values = era_cv_obj.getValues;
          var tokens_minted_values = tokens_minted_cv_obj.getValues;
          var tokens_price_values = price_cv_obj.getValues;
          var tokens_price_values3 = price_cv_obj3.getValues;

          function convertValuesToChartData(values, value_mod_function) {
            var chart_data = []
            for (var i = 0; i < values.length; i++) {
              if(values[i][1].isZero && values[i][1].isZero()) {
                continue;
              }
              if(value_mod_function == undefined) {
                value_mod_function = function(v){return v};
              }
            if(values[i][0] > ethblockstart){
              chart_data.push({
                x: values[i][0],
                y: value_mod_function(values[i][1]),
              })
            }    
            }
            return chart_data;
          }

          function getErasPerBlockFromEraData(era_values) {
            var chart_data = []
            for (var step = 1; step < era_values.length; step++) {
              var eth_blocks_passed = era_values[step][0] - era_values[step-1][0];
              var eras_passed = era_values[step][1] - era_values[step-1][1];

              if (eth_blocks_passed == 0) {
                continue;
              }

              var eras_per_eth_block = eras_passed / eth_blocks_passed * 7;

              chart_data.push({
                x: era_values[step][0],
                y: eras_per_eth_block,
              })
            }
            return chart_data;
          }

          var difficulty_data = convertValuesToChartData(target_values, 
                                                         (x)=>{return _MAXIMUM_TARGET_BN_OLD.div(x)});
          
          Chart.defaults.global.defaultFontColor = '#f2f2f2';

          var era_data = convertValuesToChartData(era_values);
          var total_supply_data = convertValuesToChartData(tokens_minted_values, 
                                                           (x)=>{return x * 1 / 10**18});
          var total_price_data = convertValuesToChartData(tokens_price_values, 
                                                           (x)=>{return 1 / x });
          var total_price_data3 = convertValuesToChartData(tokens_price_values3, 
                                                           (x)=>{return x });

          const scaleFactor = 10000000;
          let resultGraph = total_price_data.map((item, index) => {
            if (total_price_data[index].y === 0) {
              console.error("Division by zero at index " + index);
              return null;
            }
            return {
              x: item.x,
              y:(item.y)*scaleFactor
            };
          });

          let result2 = total_price_data.map((item, index) => {
            if (total_price_data[index].y === 0) {
              console.error("Division by zero at index " + index);
              return null;
            }
            return {
              x: item.x,
              y: item.y
            };
          });

          let avgPriceAtTime = total_price_data3.map((item, index) => {
            if (result2[index] && result2[index].y !== 0) {
              return {
                x: item.x,
                y: item.y * result2[index].y
              };
            }
            return null;
          }).filter(item => item !== null);

          var eras_per_block_data = getErasPerBlockFromEraData(era_values);
          var average_reward_time_data = [];
          for(var i = 0; i < eras_per_block_data.length; i += 1) {
            if(eras_per_block_data[i].x > ethblockstart){
              average_reward_time_data.push({
                x: eras_per_block_data[i].x,
                y: 1 / (eras_per_block_data[i].y * adjustAverageRewardTimeGraph),
              })
            }
          }

  var hashrate_data = getHashrateDataFromDifficultyAndErasPerBlockData(difficulty_data, eras_per_block_data);

console.log("hashrate_data :", hashrate_data);
var max_hashrate_value = 0

  for (var i = 0; i < hashrate_data.length; i += 1) {
	//console.log("max_hashrate_value22 ", hashrate_data[i].y)

    /* get max hashrate data, note - not a BN */
    if (hashrate_data[i].y > max_hashrate_value) {
console.log("max_hashrate_value ", hashrate_data[i].y)

      max_hashrate_value = hashrate_data[i].y;
    }
  }
	  // Check if the last value in hashrate_data is 0 and remove it if true
if (hashrate_data.length > 0 && hashrate_data[hashrate_data.length - 1].y === 0) {
    hashrate_data.pop();
}


          var datasetCopy = [
            average_reward_time_data.slice(0, 1)[0], 
            average_reward_time_data.slice(average_reward_time_data.length-1, average_reward_time_data.length)[0],
          ]
          if (datasetCopy[0]) {
            datasetCopy[0] = Object.assign({}, datasetCopy[0]);
            datasetCopy[1] = Object.assign({}, datasetCopy[1]);
            datasetCopy[0].y = _IDEAL_BLOCK_TIME_SECONDS / 60;
            datasetCopy[1].y = _IDEAL_BLOCK_TIME_SECONDS / 60;
          }

          // Calculate revenue data
          let avgRevenue = [];
          if (avgPriceAtTime.length > 0 && difficulty_data.length > 0) {
            for (let i = 0; i < Math.min(avgPriceAtTime.length, difficulty_data.length); i++) {
              if (avgPriceAtTime[i] && difficulty_data[i] && difficulty_data[i].y) {
                let difficultyValue = typeof difficulty_data[i].y.toNumber === 'function' 
                  ? difficulty_data[i].y.toNumber() 
                  : difficulty_data[i].y;
                
                let revenue = (31000000000 * 4320000 * 8 / (10 * difficultyValue * 2**22)) * avgPriceAtTime[i].y;
                avgRevenue.push({
                  x: difficulty_data[i].x,
                  y: revenue
                });
              }
            }
          }

          // Create Difficulty Chart
          // Create Difficulty Chart
var hr_diff_chart = new Chart.Scatter(document.getElementById('chart-hashrate-difficulty').getContext('2d'), {
    type: 'line',
    data: {
        datasets: [{
            label: "Difficulty",
            showLine: true,
            steppedLine: 'before',
            backgroundColor: 'rgb(255, 99, 132)',
            borderColor: 'rgb(255, 99, 132)',
            data: difficulty_data,
            fill: false,
        }, {
            label: "Based Work Token Hashrate",
            showLine: true,
            backgroundColor: 'rgb(156, 204, 101)',
            borderColor: 'rgb(156, 204, 101)',
            data: hashrate_data,
            fill: false,
            yAxisID: 'y-axis-2', // Changed from 'second-y-axis'
        }]
    },
    options: { 
        responsive: true,
        maintainAspectRatio: true,
        scales: {
            xAxes: [{
                gridLines: {
                    color: 'rgb(97, 97, 97)',
                    zeroLineColor: 'rgb(97, 97, 97)',
                },
                ticks: {
                    callback: function(value, index, values) {
                        return BWORKethBlockNumberToDateStr(value);
                    },
                }
            }],
            yAxes: [{
                id: 'y-axis-1', // Added ID for first y-axis
                type: 'linear',
                position: 'left',
                gridLines: {
                    color: 'rgb(97, 97, 97)',
                    zeroLineColor: 'rgb(97, 97, 97)',
                },
                scaleLabel: {
                    display: true,
                    labelString: 'Difficulty',
                    fontColor: 'rgb(255, 99, 132)',
                },
                ticks: {
                    callback: function(value, index, values) {
                        return toReadableThousandsLong(value);
                    },
                }
            }, {
                id: 'y-axis-2', // Added second y-axis
                type: 'linear',
                position: 'right',
                gridLines: {
                    drawOnChartArea: false, // Only show grid lines for left axis
                },
                scaleLabel: {
                    display: true,
                    labelString: 'Hashrate (MH/s)',
                    fontColor: 'rgb(156, 204, 101)',
                },
                ticks: {
                    callback: function(value, index, values) {
                        return toReadableHashrate(value);
                    },
                }
            }]
        }
    }
});

          // Create Price Chart
          var price_chart = new Chart.Scatter(document.getElementById('chart-pricetime').getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: "USD Price of 1 BWORK",
                    showLine: true,
                    backgroundColor: 'rgb(50,205,50)',
                    borderColor: 'rgb(50,205,50)',
                    data: avgPriceAtTime,
                    fill: false,
                    yAxisID: 'first-y-axis'
                },{
                    label: "ETH Price of 1 BWORK",
                    showLine: true,
                    backgroundColor: 'rgb(158, 168, 219)',
                    borderColor: 'rgb(158, 168, 219)',
                    data: resultGraph,
                    fill: false,
                    yAxisID: 'second-y-axis'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return BWORKethBlockNumberToDateStr(value);
                            },
                        }
                    }],
                    yAxes: [{
                        id: 'first-y-axis',
                        position: 'left',
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'USD Price',
                            fontColor: 'rgb(50,205,50)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return '$' + value.toFixed(4);
                            },
                        }
                    }, {
                        id: 'second-y-axis',
                        position: 'right',
                        scaleLabel: {
                            display: true,
                            labelString: 'ETH Price',
                            fontColor: 'rgb(158, 168, 219)',
                        },
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                            drawOnChartArea: false,
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return (value / scaleFactor).toFixed(8) + ' ETH';
                            },
                        }
                    }]
                }
            }
          });

          // Create Block Time & Supply Chart
          var rewardtime_chart = new Chart.Scatter(document.getElementById('chart-rewardtime').getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: "Average Reward Time",
                    showLine: true,
                    backgroundColor: 'rgb(79, 195, 247)',
                    borderColor: 'rgb(79, 195, 247)',
                    data: average_reward_time_data,
                    fill: false,
                    yAxisID: 'first-y-axis'
                }, {
                    label: 'Target Reward Time',
                    showLine: true,
                    fill: false,
                    backgroundColor: 'rgb(0, 255, 0)',
                    borderColor: 'rgb(0, 255, 0)',
                    borderDash: [5, 15],
                    pointRadius: 0,
                    data: datasetCopy,
                    yAxisID: 'first-y-axis',
                },{
                    label: "Total Supply",
                    showLine: true,
                    backgroundColor: 'rgb(255, 152, 0)',
                    borderColor: 'rgb(255, 152, 0)',
                    data: total_supply_data,
                    fill: false,
                    yAxisID: 'second-y-axis'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return BWORKethBlockNumberToDateStr(value);
                            },
                        }
                    }],
                    yAxes: [{
                        id: 'first-y-axis',
                        position: 'left',
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'Reward Time (Minutes)',
                            fontColor: 'rgb(79, 195, 247)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return value.toFixed(1) + ' min';
                            },
                        }
                    }, {
                        id: 'second-y-axis',
                        position: 'right',
                        scaleLabel: {
                            display: true,
                            labelString: 'Total Supply (BWORK)',
                            fontColor: 'rgb(255, 152, 0)',
                        },
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                            drawOnChartArea: false,
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return toReadableThousands(value);
                            },
                        }
                    }]
                }
            }
          });

          // Create Average Revenue Chart
          var revenue_chart = new Chart.Scatter(document.getElementById('chart-AvgRevenue').getContext('2d'), {
            type: 'line',
            data: {
                datasets: [{
                    label: "24 Hour Revenue @ 31 Gh/s",
                    showLine: true,
                    backgroundColor: 'rgb(50,205,50)',
                    borderColor: 'rgb(50,205,50)',
                    data: avgRevenue,
                    fill: false,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    xAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return BWORKethBlockNumberToDateStr(value);
                            },
                        }
                    }],
                    yAxes: [{
                        gridLines: {
                            color: 'rgb(97, 97, 97)',
                            zeroLineColor: 'rgb(97, 97, 97)',
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'Daily Revenue (USD)',
                            fontColor: 'rgb(50,205,50)',
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return '$' + value.toFixed(2);
                            },
                        }
                    }]
                }
            }
          });

          goToURLAnchor(); 
        }

        async function show_progress(value){
          log('updating progress.. (', value, ')');
          el('#difficultystats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
          el('#blocktimestats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
          el('#priceOverTimestats').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
          el('#avgRevenue').innerHTML = '<div class="">Loading info from the blockchain... <span style="font-weight:600;">' + value + '</span></div>';
        }

        async function updateHashrateAndBlocktimeGraph(web3Instance, start_eth_block, end_eth_block, num_search_points){
          console.log("123123Start search at: ",start_eth_block);
          console.log("123123end_eth_block: ",end_eth_block);
          
          // Create contract value trackers
          var last_diff_start_blocks = new contractValueOverTime(web3Instance, BWORK_CONTRACT_ADDRESS, BWORK_LAST_DIFF_START_BLOCK_INDEX, 'diffStartBlocks2');
          var era_values = new contractValueOverTime(web3Instance, BWORK_CONTRACT_ADDRESS, BWORK_ERA_INDEX, 'eraValues2');
          var tokens_minted_values = new contractValueOverTime(web3Instance, BWORK_CONTRACT_ADDRESS, BWORK_TOKENS_MINTED_INDEX, 'tokensMinted2');
          var tokens_price_values = new contractValueOverTime(web3Instance, '0x498581fF718922c3f8e6A244956aF099B2652b2b', '0xd66bf39be2869094cf8d2d31edffab51dc8326eadf3c7611d397d156993996da', 'BWORKETHPrice');
          var tokens_price_values3 = new contractValueOverTime(web3Instance, '0x498581fF718922c3f8e6A244956aF099B2652b2b', '0xe570f6e770bf85faa3d1dbee2fa168b56036a048a7939edbcd02d7ebddf3f948', 'USDCETHPrice');
          var mining_target_values = new contractValueOverTime(web3Instance, BWORK_CONTRACT_ADDRESS, BWORK_MINING_TARGET_INDEX, 'miningTargets2');

          // Load data with progress updates
          await tokens_price_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(500);
          show_progress('10% [42 / 420]');

          await tokens_price_values3.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(200);
          show_progress('20% [84 / 420]');

          await last_diff_start_blocks.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(200);

          // Wait for completion with progress tracking
          while (!last_diff_start_blocks.areAllValuesLoaded() || !tokens_price_values.areAllValuesLoaded() || !tokens_price_values3.areAllValuesLoaded()) {
              let numerator = tokens_price_values.states.length + tokens_price_values3.states.length + last_diff_start_blocks.states.length;
              let denominator = tokens_price_values.expected_state_length + tokens_price_values3.expected_state_length + last_diff_start_blocks.expected_state_length;
              show_progress((50 * (numerator / denominator)).toFixed(0) + '% [' + (0.5 * numerator).toFixed(0) + ' / ' + denominator.toFixed(0) + ']');
              await sleep(1000);
          }

          await sleep(3000);

          await era_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(500);
          show_progress('60% [250 / 420]');

          await tokens_minted_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);
          await sleep(500);
          show_progress('70% [350 / 420]');

          await mining_target_values.addValuesInRange(start_eth_block, end_eth_block, num_search_points);

          // Wait for all to complete
          await last_diff_start_blocks.waitUntilLoaded();
          await mining_target_values.waitUntilLoaded();
          await tokens_minted_values.waitUntilLoaded();
          await era_values.waitUntilLoaded();
          await tokens_price_values3.waitUntilLoaded();
          await tokens_price_values.waitUntilLoaded();

          // Sort and save data
          last_diff_start_blocks.sortValues();
          mining_target_values.sortValues();
          era_values.sortValues();
          tokens_minted_values.sortValues();
          tokens_price_values.sortValues();
          tokens_price_values3.sortValues();

          generateHashrateAndBlocktimeGraph(web3Instance, mining_target_values, era_values, tokens_price_values, tokens_price_values3, tokens_minted_values);
          
          document.getElementById('topText').style.display = 'none';
          document.getElementById('topText2').style.display = 'none';
          
          // Save to localStorage
          era_values.saveToLocalStorage(num_search_points);
          mining_target_values.saveToLocalStorage(num_search_points);
          last_diff_start_blocks.saveToLocalStorage(num_search_points);
          tokens_minted_values.saveToLocalStorage(num_search_points);
          tokens_price_values.saveToLocalStorage(num_search_points);
          tokens_price_values3.saveToLocalStorage(num_search_points);
        }

        function updateGraphData(history_days, num_search_points) {
          show_progress('0% [0 / 0]');

          setTimeout(async ()=>{
            while(BWORK_latest_eth_block == null) {
              log('waiting for BWORK_latest_eth_block...');
              await sleep(300);
            }

            const eth_blocks_per_day = 24*60*(60/_SECONDS_PER_ETH_BLOCK);
            log("_SECONDS_PER_ETH_BLOCK..."+eth_blocks_per_day);
          
            let max_blocks = history_days*eth_blocks_per_day;
            if (max_blocks / num_search_points > eth_blocks_per_day) {
              log("WARNING: search points are greater than 1 day apart. Make sure you know what you are doing...");
            }

            num_search_points = history_days;   
            searchPoints2 = num_search_points
            let start_eth_block = (BWORK_latest_eth_block-max_blocks);
            if(start_eth_block < 30413732){
                start_eth_block = 30413732;
            }
              
            log("latest_eth_block..."+latest_eth_block);
            log("BWORK_latest_eth_block..."+BWORK_latest_eth_block);
            log("USING BWORK_LATEST_ETH_BLOCK RIGHT NOW BWORK_latest_eth_block..."+BWORK_latest_eth_block);
            log("latest_eth_block max_blocks..."+max_blocks);
            log("latest_eth_block...="+(latest_eth_block-max_blocks));
            log("latest_eth_block max_blocks..."+start_eth_block);
            let end_eth_block = BWORK_latest_eth_block-8;

            console.log("zz123123Start search at: ",start_eth_block);
            console.log("zz123123end_eth_block: ",end_eth_block);
            updateHashrateAndBlocktimeGraph(web3, start_eth_block, end_eth_block, num_search_points);

          }, 0); 
        }

        // Initialize when page loads
        window.addEventListener('load', async () => {
            await initEth();
            // Automatically load 30 days of data
            updateGraphData(30, 30);
        });
    </script>
</body>
</html>
